class GaussField:

    def __init__(self, value, primeNumber):
        self.primeNumber = primeNumber
        self.value = self.__number(value)

    def __number(self, b):
        if b < 0:
            while b < 0:
                b += self.primeNumber
            return b
        return b % self.primeNumber

    def add(self, b):
        return self.__number(self.value + b)
    
    def __add__(self, other):
        return self.__number(self.value + other.value)

    def subtract(self, b):
        return self.__number(self.value - b)
    
    def __sub__(self, other):
        return self.__number(self.value - other.value)

    def multiply(self, b):
        return self.__number(self.value*b)
    
    def __mul__(self, other):
        return self.__number(self.value * other.value)

    def __invert(self, b):
        temp = self.value
        self.value = self.__number(b)
        for i in range(self.primeNumber):
            if self.multiply(i) == 1:
                self.value = temp
                return i
        self.value = temp
        # w ciele GF1234577 wszystkie elementy są odwracalne, ale, jeżeli zamiast liczby pierwszej zostanie podana liczba złożona, to pojawią się elementy nieodwracalne
        # wtedy zostanie zwrócone -1
        return -1

    def divide(self, b):
        if b == 0:
            raise ValueError("You can't divide by zero.\n")
        inverted = self.__invert(b)
        if inverted == -1:
            raise ValueError("Cannot invert {}\n".format(b))
        return self.multiply(inverted)

    def __div__(self, other):
        if other.value == 0:
                raise ValueError("You can't divide by zero.\n")
        inverted = self.__invert(other.value)
        # w ciele nie ma elementów nieodwracalnych, ale gdyby nie podano liczby, która jest pierwsza
        # to takie by się pojawiły
        if inverted == -1:
            raise ValueError("Cannot invert {}\n".format(other.value))
        return self.__mul__(GaussField(inverted, self.primeNumber))

    def substitute(self, b):
        self.value = self.__number(b)

    def addAndSubst(self, b):
        self.substitute(self.add(b))

    def __iadd__(self, other):
        self.value = self.__add__(other)
        return self
    
    def subtractAndSubst(self, b):
        self.substitute(self.subtract(b))

    def multiplyAndSubst(self, b):
        self.substitute(self.multiply(b))

    def divideAndSubst(self, b):
        self.substitute(self.divide(b))

    def checkIfEqual(self, b):
        if self.value == self.__number(b):
            return True
        return False
    
    def checkIfNotEqual(self, b):
        if self.value != self.__number(b):
            return True
        return False
    
    def checkIfThisGreater(self, b):
        if self.value > self.__number(b):
            return True
        return False
    
    def checkIfThisSmaller(self, b):
        if self.value < self.__number(b):
            return True
        return False
    
    def checkIfThisGreaterEqual(self, b):
        if self.value >= self.__number(b):
            return True
        return False

    def checkIfThisSmallerEqual(self, b):
        if self.value <= self.__number(b):
            return True
        return False